<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: os161 | Pearls in Life]]></title>
  <link href="http://jhshi.me/category/os161/atom.xml" rel="self"/>
  <link href="http://jhshi.me/"/>
  <updated>2013-04-04T18:36:39-04:00</updated>
  <id>http://jhshi.me/</id>
  <author>
    <name><![CDATA[Jinghao Shi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[OS161 Synchronization Primitives: Semaphore]]></title>
    <link href="http://jhshi.me/2013/04/04/os161-synchronization-primitives-semaphore/"/>
    <updated>2013-04-04T14:52:00-04:00</updated>
    <id>http://jhshi.me/2013/04/04/os161-synchronization-primitives-semaphore</id>
    <content type="html"><![CDATA[<p><a href="http://en.wikipedia.org/wiki/Semaphore_(programming)">Semaphore</a> denotes a certain number of shared resources. Basically, it's
one counter and two operations on this counter, namely <code>P</code> and <code>V</code>. <code>P</code> is used
to acquire one resource (thus decrementing the counter) while <code>V</code> is used to
release one resource (thus incrementing the counter).</p>

<!-- more -->


<h3>A Metaphor</h3>

<p>My favorite example is the printer. Say we have three printers in a big lab,
where everybody in the lab shared those printers. Obviously only one printing
job can be conducted by one printer at any time, otherwise, the printed content
would be messed up.</p>

<p>However, we can not use a single lock to protect the access of all these three
printers. It'll be very dumb. An intuitive way is to use three locks, one for
each printer. Yet more elegantly, we use a semaphore with initial counter as 3.
Every time before a user submit a print job, he need to first <code>P</code> this semaphore
to acquire one printer. And after he is done, he need to <code>V</code> this semaphore to
release the printer. If there is already one print job at each printer, then the
following poor guys who want to <code>P</code> this semaphore would have to wait.</p>

<h3>What should a semaphore structure contain?</h3>

<p>Apparently, we need an <strong>counter</strong> to record how many resources available. Since
this counter is a shared variable, we need a <strong>lock</strong> to protect it. At this point,
we only have the <code>spinlock</code> provided in <code>$OS161_SRC/kern/include/spinlock.h</code>.
That's fine since our critical section is short anyway. In order to let the poor
guys have a place to wait, we also need an <strong>wait channel</strong> (in
<code>OS161_SRC/kern/include/wchan.h</code>)</p>

<h3><code>P</code> Operation</h3>

<p>The flow of <code>P</code> would be:</p>

<ol>
<li>Acquire the spin lock</li>
<li>Check if there are some resources available (<code>counter &gt; 0</code>)</li>
<li>If yes, we're lucky. Happily go to step 8.</li>
<li>If no, then we first grab the lock of the wait channel, since the wait
channel is also shared.</li>
<li>Release the spin lock, and wait on the wait channel by calling <code>wchan_sleep</code></li>
<li>We're sleeping...</li>
<li>After wake up, first grab the spin lock, and go to step 2</li>
<li>At this point, the <code>counter</code> should be positive, decrement it by 1</li>
<li>Release the spin lock, and return</li>
</ol>


<h3><code>V</code> Operation</h3>

<p><code>V</code> is much simpler compared to <code>P</code>. The flow is:</p>

<ol>
<li>Acquire the spin lock</li>
<li>Increment the <code>counter</code> by 1</li>
<li>Wake up some poor guy in the wait channel by calling <code>wchan_wakeone</code>)</li>
<li>Release the spin lock and return</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Console Input Messed up in OS161]]></title>
    <link href="http://jhshi.me/2013/03/15/console-input-messed-up-in-os161/"/>
    <updated>2013-03-15T00:26:57-04:00</updated>
    <id>http://jhshi.me/2013/03/15/console-input-messed-up-in-os161</id>
    <content type="html"><![CDATA[<p>When you finished the process system call (e.g., <code>fork</code>, <code>execv</code>) and test your
system call by executing some user program, you'll probably find that the
console input behavior is messed up.</p>

<!-- more -->


<p>For example, when you executing user shell from OS161 kernel menu, and then
executing <code>/bin/true</code> from the shell, you may see this</p>

<p><code>bash
OS/161 kernel [? for menu]: s
Operation took 0.000285120 seconds
OS/161 kernel [? for menu]: (program name unknown): Timing enabled.
OS/161$ /bin/true
(program name unknown): bntu: No such file or directory
(program name unknown): subprocess time: 0.063300440 seconds
Exit 1
</code></p>

<p>In this case, the shell program only receive the input "bnut" instead of your
input (<code>/bin/true</code>).</p>

<p>To find out why, we need to dig into how kernel menu (<code>$OS161_SRC/kern/startup/menu.c</code>)
works a little bit. When you hit "s" in the kernel menu. What happens?</p>

<ol>
<li><p><code>cmd_dispatch</code> will look up the <code>cmd_table</code> and call <code>cmd_shell</code></p></li>
<li><p><code>cmd_shell</code> just call <code>common_prog</code> with the shell path argument</p></li>
<li><p><code>common_prog</code> will first create a child thread with the start function
<code>cmd_progthread</code>, then return</p></li>
<li><p>In the child thread, <code>cmd_progthread</code> will try to run the actual program
(in our case, the shell)</p></li>
</ol>


<p>Note that the shell program is run in a separate child thread, and the parent
thread (i.e., the menu thread) will continue to run after he "forked" the child
thread.</p>

<p>So now there are actually two thread that want to read console input, which
leads to race condition. This is why the shell program receive corrupted input:
the menu thread eaten some of the inputs!</p>

<p>To solve this problem, we need to let the menu thread wait for the child
thread to complete, then return. So what we need to do is in <code>common_prog</code>, we
need to do a <code>waitpid</code> operation after we call <code>thread_fork</code>. And at the end of
<code>cmd_progthread</code>, we need to explicitly call <code>exit</code> with proper exit code in
case the user program doesn't do this.</p>

<p>Also note that <code>waitpid</code> and <code>exit</code> are in fact user land system call, and we can
not directly call them in kernel, so you may need to make some "shortcuts" in
your system call implementation to let the kernel be able to call <code>sys_waitpid</code>
and <code>sys_exit</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OS161 SAME_STACK Check Fail in Trap]]></title>
    <link href="http://jhshi.me/2012/05/02/os161-same_stack-check-fail-in-trap/"/>
    <updated>2012-05-02T14:02:11-04:00</updated>
    <id>http://jhshi.me/2012/05/02/os161-same_stack-check-fail-in-trap</id>
    <content type="html"><![CDATA[<p>There are several <code>SAME_STACK</code> asserts in <code>$OS161_SRC/kern/arch/mips/locore/trap.c</code> to
ensure that <strong>current thread did not run out of kernel stack</strong>.</p>

<!-- more -->


<p>A typical assert may looks like:</p>

<p><code>c
KASSERT(SAME_STACK(cpustacks[curcpu-&gt;c_number]-1, (vaddr_t)tf))
</code></p>

<p>During the lab, I sometimes fail this assert. At first, I thought I've run
out of kernel stack so I enlarge the <code>STACK_SIZE</code> (<code>$OS161_SRC/kern/include/thread.h</code>)
to 16 KB. But I still fail this assert after that. Then I take a look at the
definition of the <code>SAME_STACK</code> macro:</p>

<p>```c</p>

<h1>define SAME_STACK(p1, p2) (((p1) &amp; STACK_MASK) == ((p2) &amp; STACK_MASK))</h1>

<p>```</p>

<p>I found this macro problematic. Suppose <code>STACK_SIZE = 0X00004000</code>, then
<code>STACK_MASK = ~(STACK_SIZE-1) = 0XFFFFC000</code>. Assume <code>p1 (stack top) =
0X80070FFF</code>, <code>p2 (stack pointer) = 0x8006FFFF</code>, then we've only used 0x00001000
bytes stack but <code>SAME_STACK</code> macro will fail, since <code>p1 &amp; STACK_MASK =
0X80070000, p2 &amp; STACK_MASK = 0X8006C000.</code></p>

<p><strong>The point here is the stack top address may not be STACK_SIZE aligned. So we
can not do the same stack check by simply checking their base addresss.</strong></p>

<p>So we need to modify this part to get our kernel work. This is not your fault
but probably a bug shipped with the kernel.</p>

<p>You can use any tricky macros here but a simple pair of comparison will be
suffice.</p>

<p><code>c
KASSERT(((vaddr_t)tf) &gt;= ((vaddr_t)curthread-&gt;t_stack));
KASSERT(((vaddr_t)tf) &lt; ((vaddr_t)curthread-&gt;t_stack+STACK_SIZE));
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OS161 Duplicated TLB entries]]></title>
    <link href="http://jhshi.me/2012/05/02/os161-duplicated-tlb-entries/"/>
    <updated>2012-05-02T13:18:47-04:00</updated>
    <id>http://jhshi.me/2012/05/02/os161-duplicated-tlb-entries</id>
    <content type="html"><![CDATA[<p>Sys161 will panic if you try to write a TLB entry with a <code>entryhi</code>, but
there are already a TLB entry with the same <code>entryhi</code> but in a different TLB
slot. This is because <strong>entryhi should be a UNIQUE key in the TLB bank.</strong></p>

<!-- more -->


<p>When you want to update a TLB entry (e.g., shoot down a TLB entry, or set the
Dirty bit, etc.), you need to first use <code>tlb_probe</code> to query the TLB bank to get
the TLB slot index and then use <code>tlb_read</code> to read the original value, and then
use <code>tlb_write</code> to write the updated TLB entry value to this slot. <strong>But what
if there is a interrupt after you <code>tlb_probe</code> but before <code>tlb_read</code>?</strong> Chance
maybe that the TLB bank is totally refreshed so that you read a stale value
and also write a stale value. Things get totally messed up and errors such as
"Duplicated TLB entries" may occur.</p>

<p>To resolve this, <strong>you need to protect your whole "<code>tlb_probe</code>-><code>tlb_read</code>->
<code>tlb_write</code>" flow and make sure that this flow won't get interrupted.</strong> So you
really want to disable interrupt (<code>int x = splhigh()</code>) before you do <code>tlb_probe</code>
and re-enable it (<code>splx(x)</code>) after <code>tlb_write</code>. Alternatively, you can also use a
spin lock to protect your access to TLB.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OS161 Swapping]]></title>
    <link href="http://jhshi.me/2012/04/28/os161-swapping/"/>
    <updated>2012-04-28T13:27:39-04:00</updated>
    <id>http://jhshi.me/2012/04/28/os161-swapping</id>
    <content type="html"><![CDATA[<p>Now that you can <a href="/2012/04/24/os161-physical-page-management">allocate/free physical pages</a>, and you have <a href="/2012/04/27/os161-tlb-miss-and-page-fault">demand paging
through handling TLB miss</a>. Let's get the final part work: swapping.</p>

<!-- more -->


<h3>Three basic operations for a physical page</h3>

<p>The first is called <strong>evict</strong>. In a nutshell, <code>evict</code> a physical page means we
modify the page table entry so that this page is not Present (<code>PTE_P</code>), but
Swapped (<code>PTE_S</code>). And we also need to shoot down the relative TLB entry. But in
<code>evict</code>, we will not write the page's content to disk. Apparently, <strong>evict can
only operate on clean pages</strong>.</p>

<p>The second operation is <strong>swapout</strong>. We first write this page's content to
disk, which makes the page from dirty to clean. And the we just evict it.
<strong>swapout operation is for dirty pages</strong>.</p>

<p>The last operations is <strong>swapin</strong>. Basically, it's for read some virtual page
from swap file and place it in some physical page, and also need to modify
the relevant page table entry, making this page Present (<code>PTE_P</code>) instead of
Swapped(<code>PTE_S</code>).</p>

<h3>How to store the swapped pages</h3>

<p>We have two options here: store the pages in a <strong>disk</strong>, or in a <strong>file</strong>.</p>

<p>By default, sys161 provide two disks through lamebus, i.e., <code>lhd0</code> and <code>lhd1</code>. If
you want to store the pages in the raw disk, you should open the swap space like
this:</p>

<p>```c
struct vnode* swapfile;
int err = vfs_open("lhd0raw:", O_RDWR, 0, &amp;swapfile);
if (err != 0) {</p>

<pre><code>return err;
</code></pre>

<p>}
```</p>

<p>Note that the file name must be <code>lhd0raw:</code> or <code>lhd1raw</code> and the open flag must
be <code>O_RDWR</code>, since the disk is there, and needn't to be created or trunked.</p>

<p>On the other hand, if you decided to just store the pages in a normal file, then
you probably want to create the file like this:</p>

<p>```c
struct vnode* swapfile;
int err = vfs_open("swapfile", O_RDWR|O_CREAT|O_TRUNC, 0, &amp;swapfile);
if (err != 0) {</p>

<pre><code>return err;
</code></pre>

<p>}
```</p>

<p>The file name is arbitrary, just choose one you like. And we provide the
<code>O_TRUNC</code> flag so that we got a "clean" swap file that contains no contents.
Then the file will be created under the root directory.</p>

<p>From my experience, store pages in normal file could be two times faster in
terms of read/write bandwidth.</p>

<p>For the same reason why we can not open consoles in <code>thread_create</code>, you can not
do this in <code>vm_bootstrap</code> since at that point, VFS system
was not initialized yet (see <code>$OS161_SRC/kern/startup/main.c</code> for boot sequence,
especially line 125~130). But it's OK, we can <strong>open the file until we really
need to write pages</strong>, e.g., when we swap out the first page.</p>

<p>We'll leverage the file operation to manipulate swapped pages. You may want to
review the file operation system calls to get familiar with VFS operations. We
use a lot <code>uio_kinit</code> and <code>VOP_READ</code>/<code>VOP_WRITE</code> here. But before all these, we need
to first create a swap file.</p>

<p>We also need some data structure to record each page's location in the swap
file. This data structure should be something like a map. The key is (address
space, va) pair, and the value is the location of the page. As usual, for
simplicity, we can just use a statically allocated array. <strong>Each array element
contains the (address space, va) pair, and this element's index is the page's
location</strong>. Of course, we need to set up a limit of maximum swapped page number
if we adopt this silly manner. When swap out a page, we first look up this
array (by comparing <code>as</code> and <code>va</code>) and find out if the swap file has already
contain a copy of this page, if yes then we directly overwrite that page and if
no, we just find a available slot and write the page to that slot.</p>

<p>A important note is that you want to <strong>create ONE swap file for all process</strong>,
instead of one swap file for each process. Since by doing the later, you also
have to allocate a mapping structure for each process and you'll run out of
memory very quickly (kernel pages are fixed, right?). Now the swap file and the
mapping data structure is a shared resource among all processes. So you need to
protect them with a lock.</p>

<h3>Two I/O operations on the swap file</h3>

<p>These two operations is quite straightforward. The first is called <code>write_page</code>,
which is responsible to <strong>write a page content to a specified location of the
swap file</strong>. The second is <code>read_page</code>, which is to <strong>read a specified page in
the swap file and copy the content to a physical page</strong>. We do not necessarily
have to have these to util functions but it's always good to abstract low level
operations and encapsulate to a convenient interface.</p>

<h3>The Swapping Work flow</h3>

<p>In your paging algorithm, you certainly will first look for free physical
pages. But once you fail to find such a page, you have to swap some page out
to get a free page. That's what the magic function <code>MAKE_PAGE_AVAIL</code> do in
<a href="/2012/04/24/os161-physical-page-management">my previous post about physical page allocation</a>.</p>

<p>Now let's take a look at the magic function. Denote the page that was to
swapped out as victim. If it's state is <code>PAGE_STATE_CLEAN</code>, it means that this
page already have a copy in disk and was not ever modified since swapped in. So
we can safely discard it's content. We use the <code>evict</code> operation to deal with it.
And after that, this page is available.</p>

<p>If this page is dirty, which means either this page do not have a copy in swap
file or this page was modified since it's swapped in, in both case, we need to
write its content to swap file. We can use the <code>swapout</code> operation here.</p>

<p>In <code>vm_fault</code> with fault type <code>VM_FAULT_READ</code> or <code>VM_FAULT_WRITE</code>, when we find that
this page is not Present (<code>PTE_P</code>), instead of allocate a new page for it, we
need to further check if this page was swapped (<code>PTE_S</code>), if yes then we need to
swap it in, if no then we can allocate a new physical page for it.</p>
]]></content>
  </entry>
  
</feed>
